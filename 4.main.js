(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{268:function(e,n,t){"use strict";t.r(n),t.d(n,"title",(function(){return h}));var a=t(3),s=t.n(a),o=t(0),r=t.n(o),i=t(2),c=t(17),p=t.p+"b8720bc50bbc064e12342669f93849f9.jpg",m=t.p+"002-example.html",h="A simple fetch() interceptor with VanillaJS";n.default=function(e){var n=e.components;s()(e,["components"]);return r.a.createElement(i.MDXTag,{name:"wrapper",components:n},r.a.createElement(c.a,{title:h,src:p,author:r.a.createElement("span",null,"Photo by ",r.a.createElement("a",{href:"https://unsplash.com/@hidd3n?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"},"Kevin Horvat")," on ",r.a.createElement("a",{href:"https://unsplash.com/s/photos/monitors?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"},"Unsplash"))}),r.a.createElement(i.MDXTag,{name:"p",components:n},"The introduction of the ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"Fetch API")," brought a modern and comprehensive method of making HTTP calls to browsers."),r.a.createElement(i.MDXTag,{name:"p",components:n},"In the development of more complex web applications, however, there is a need to have ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"more control")," over the requests and their responses."),r.a.createElement(i.MDXTag,{name:"p",components:n},"Some frameworks and libraries provide ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"alternative or similar methods to fetch()"),",\nand with it some tools to ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"intercept")," the requests before they are made or the responses before they are digested, allowing their ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"manipulation")," to normalize them according to business needs (e.g. add authentication HTTP headers), or to perform ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"predefined actions")," in some circumstances (e.g. toast notifications in case of error responses)."),r.a.createElement(i.MDXTag,{name:"h2",components:n,props:{id:"a-vanillajs-interceptor"}},"A ",r.a.createElement(i.MDXTag,{name:"em",components:n,parentName:"h2"},"Vanilla.js")," interceptor"),r.a.createElement(i.MDXTag,{name:"p",components:n},"Here below I report the ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"ES6 class")," code of an interceptor, which proves to be very simple and tries to exploit the already rich native ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"fetch API")," without distorting them,\ntherefore it does ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"not force to adopt proprietary formats")," when creating the request or reading the response."),r.a.createElement(i.MDXTag,{name:"pre",components:n},r.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metastring:""}},'class Interceptor {\n\n  // The arrays that will contain the interception functions are prepared at the instantiation,\n  // for requests and responses\n  constructor () {\n    this.requests = [];\n    this.responses = [];\n  }\n\n  // Method for defining a function that intercepts and, if necessary, modifies HTTP requests\n  interceptRequest (fn) {\n    this.requests.push(fn);\n  }\n\n  // Method for defining a function that intercepts and, if necessary, modifies HTTP responses\n  interceptResponse (fn) {\n    this.responses.push(fn);\n  }\n\n  // Method that returns a function with the same signature as the native fetch()\n  // (therefore you can rely on the standard),\n  // but which manages the previously defined interceptors\n  getFetcher () {\n    return async (input, init) => {\n\n      // The request interceptor manages the native "Request" type,\n      // so if an instance of Request has not already been passed\n      // the function expects to create it\n      let request = (input instanceof Request) ? input : new Request(input, init);\n\n      // The request instance is processed through all the request interceptor functions\n      for(const fn of this.requests) {\n        // The interceptor response must be an instance of Request\n        // or a Promise that resolves with an instance of Request\n        const res = fn(request);\n        request = (res instanceof Promise) ? await res : res;\n      }\n\n      // The request is made via the native fetch() function, passing the processed "Request" instance\n      let response = await window.fetch(request);\n\n      // The response instance is processed through all the response interceptor functions\n      for(const fn of this.responses) {\n        // The interceptor response must be an instance of Response\n        // or a Promise that resolves with an instance of Response\n        const res = fn(response);\n        response = (res instanceof Promise) ? await res : res;\n      }\n\n      // The result of the function is the processed "Response" instance\n      return response;\n    };\n  }\n}\n')),r.a.createElement(i.MDXTag,{name:"h2",components:n,props:{id:"an-example-of-use"}},"An example of use"),r.a.createElement(i.MDXTag,{name:"p",components:n},"Here is an example of use, very simple in this case.\nBy taking advantage of the ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"ES modules")," and dividing the code over ",r.a.createElement(i.MDXTag,{name:"em",components:n,parentName:"p"},"different files"),",\nyou can develop a modern and simple method to make fetch() calls."),r.a.createElement(i.MDXTag,{name:"pre",components:n},r.a.createElement(i.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-javascript",metastring:""}},'// Create the instance of interceptor management\nconst interc = new Interceptor();\n\n// Set an interceptor function for the request\ninterc.interceptRequest((request) => {\n  // Create a new Request with adding Authorization header,\n  // for example, as value, an authentication token stored in the web-app\n  return new Request(request, {\n    headers: {\n      "Authorization": `Bearer ${storedAuthToken}`\n    }\n  })\n});\n\n// Set an interceptor function for the response\ninterc.interceptResponse(async (response) => {\n  // Clone the answer to be able to process it in the interceptor\n  // (the response buffer can be used only once, in doing so I leave it available for subsequent processing)\n  const responseClone = response.clone();\n  if(responseClone.status === 401) {\n    window.location = "https://.../login-page";\n  }\n  // Return the original response\n  return response;\n});\n\n// Get a function that uses fetch() with interceptors\nconst interceptedFetch = interc.getFetcher();\n\n// ...\n\n// Where necessary I use the function obtained to make requests.\n// The authentication header will be added before making the request\n// Before returning the response, the status will be analyzed and predefined operations executed\ninterceptedFetch(`https://.../my-endpoint`, {\n  method: "POST",\n  body: JSON.stringify({foo: "bar"})\n});\n')),r.a.createElement(i.MDXTag,{name:"p",components:n},r.a.createElement("a",{href:m},"View Live Example")),r.a.createElement(i.MDXTag,{name:"p",components:n},"In my ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"HTNA-tools")," repository on github you can find the original ",r.a.createElement(i.MDXTag,{name:"strong",components:n,parentName:"p"},"TypeScript")," version:\n",r.a.createElement(i.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/sandrolain/HTNA-tools/blob/8dd09d233e3856ce78199ac2dff608f21555a507/src/netw.ts#L50"}},"Click here to go to the exact line"),"."))}}}]);